name: Deploy Infrastructure and Application

on:
  # Disabled auto-trigger - use manual trigger only
  # push:
  #   branches: [main]
  workflow_dispatch:  # Manual trigger only
    inputs:
      deploy_infrastructure:
        description: 'Deploy/Update Terraform Infrastructure?'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      deploy_backend:
        description: 'Deploy Python Function App (Backend)?'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      deploy_frontend:
        description: 'Deploy React Static Web App (Frontend)?'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: 'app/backend'
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  TERRAFORM_VERSION: '1.5.0'

jobs:
  # ============================================
  # Job 0a: Run Pre-commit Checks (Code Quality)
  # ============================================
  pre-commit:
    name: 'Pre-commit Terraform Checks'
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.0'

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install pre-commit
        run: |
          python -m pip install --upgrade pip
          pip install pre-commit
          echo "âœ… pre-commit installed"

      - name: Run pre-commit checks
        run: |
          pre-commit run --all-files
          echo "âœ… Pre-commit checks passed"

  # ============================================
  # Job 0: Detect Changes (backend/frontend)
  # ============================================
  changes:
    name: 'Detect Changed Paths'
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Paths filter
        id: filter
        uses: dorny/paths-filter@v3
        with:
          # For workflow_dispatch, compares current commit to previous commit
          # Adjust filters to your project structure
          filters: |
            backend:
              - 'azure/DTE/terraform/app/backend/**'
            frontend:
              - 'azure/DTE/terraform/app/frontend/**'

  # ============================================
  # Job 1: Deploy Infrastructure with Terraform
  # ============================================
  infrastructure:
    name: 'Terraform Infrastructure'
    if: github.event.inputs.deploy_infrastructure == 'true'
    runs-on: ubuntu-latest
    outputs:
      function_app_name: ${{ steps.terraform-output.outputs.function_app_name }}
      function_app_url: ${{ steps.terraform-output.outputs.function_app_url }}
      static_web_app_name: ${{ steps.terraform-output.outputs.static_web_app_name }}
      static_web_app_url: ${{ steps.terraform-output.outputs.static_web_app_url }}
      resource_group: ${{ steps.terraform-output.outputs.resource_group }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Terraform Service Principal Environment Variables
        run: |
          # Extract service principal credentials from AZURE_CREDENTIALS secret
          echo "ARM_CLIENT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')" >> $GITHUB_ENV
          echo "âœ… Service principal environment variables set for Terraform"

      - name: Create Terraform Backend Infrastructure
        run: |
          echo "ğŸ”§ Setting up Terraform backend..."
          
          # Backend configuration
          RG_NAME="rg-terraform-state"
          STORAGE_NAME="tfstateemp"
          CONTAINER_NAME="tfstate"
          LOCATION="eastus"
          
          # Create resource group if it doesn't exist
          echo "Creating resource group: $RG_NAME"
          az group create --name "$RG_NAME" --location "$LOCATION" 2>/dev/null || echo "â„¹ï¸  Resource group already exists"
          
          # Create storage account if it doesn't exist
          echo "Creating storage account: $STORAGE_NAME"
          az storage account create \
            --resource-group "$RG_NAME" \
            --name "$STORAGE_NAME" \
            --sku Standard_LRS \
            --kind StorageV2 \
            --https-only true \
            2>/dev/null || echo "â„¹ï¸  Storage account already exists"
          
          # Create container if it doesn't exist
          echo "Creating storage container: $CONTAINER_NAME"
          az storage container create \
            --account-name "$STORAGE_NAME" \
            --name "$CONTAINER_NAME" \
            2>/dev/null || echo "â„¹ï¸  Container already exists"
          
          echo "âœ… Terraform backend infrastructure ready"

      - name: Terraform Init
        working-directory: .
        run: |
          terraform init \
            -backend-config="resource_group_name=rg-terraform-state" \
            -backend-config="storage_account_name=tfstateemp" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=terraform.tfstate"
          echo "âœ… Terraform initialized with remote backend"

      - name: Terraform Validate
        working-directory: .
        run: |
          terraform validate
          echo "âœ… Terraform configuration validated"

      - name: Terraform Format Check
        working-directory: .
        run: |
          terraform fmt -recursive -check || true
          echo "âœ… Terraform format checked"

      - name: Check if resources exist
        id: check-resources
        working-directory: .
        run: |
          # Try to get the function app - if it exists, skip terraform apply
          RESOURCE_GROUP=$(cat dev.tfvars | grep 'resource_group_name' | cut -d'=' -f2 | tr -d ' "')
          FUNCTION_APP=$(cat dev.tfvars | grep 'function_app_name' | cut -d'=' -f2 | tr -d ' "')
          
          echo "Resource Group: $RESOURCE_GROUP"
          echo "Function App: $FUNCTION_APP"
          
          if az functionapp show --resource-group "$RESOURCE_GROUP" --name "$FUNCTION_APP" &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Resources already exist - will import into state"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ Resources not found - will deploy infrastructure"
          fi

      - name: Import existing resources into Terraform state
        if: steps.check-resources.outputs.exists == 'true'
        working-directory: .
        run: |
          echo "ğŸ“¦ Scanning and importing existing Azure resources..."
          
          RESOURCE_GROUP=$(cat dev.tfvars | grep 'resource_group_name' | cut -d'=' -f2 | tr -d ' "')
          
          # Use terraform import -generate-config-out to auto-generate HCL blocks
          echo "ğŸ” Auto-generating configuration blocks for existing resources..."
          
          # Import Resource Group
          if ! terraform state show module.resource_group.azurerm_resource_group.this &>/dev/null; then
            echo "ğŸ“‹ Importing Resource Group: $RESOURCE_GROUP"
            terraform import \
              -generate-config-out=generated_rg.tf \
              module.resource_group.azurerm_resource_group.this \
              "/subscriptions/$(az account show -q --query id -o tsv)/resourceGroups/$RESOURCE_GROUP" 2>/dev/null || \
            echo "â„¹ï¸ Resource Group import/generation attempted"
          fi
          
          # Import all resources in the resource group with query
          echo "ğŸ” Scanning all resources in $RESOURCE_GROUP..."
          
          # Get all resources
          RESOURCES=$(az resource list --resource-group "$RESOURCE_GROUP" --query "[].{id:id, type:type, name:name}" -o json)
          
          # Auto-import with config generation
          import_with_generation() {
            local resource_id=$1
            local resource_type=$2
            local resource_name=$3
            local tf_resource_address=$4
            
            if [ -z "$tf_resource_address" ]; then
              return
            fi
            
            # Check if already in state
            if ! terraform state show "$tf_resource_address" &>/dev/null; then
              echo "ğŸ“¥ Importing and generating config for: $resource_name ($resource_type)"
              terraform import \
                -generate-config-out="generated_${resource_name}.tf" \
                "$tf_resource_address" \
                "$resource_id" 2>/dev/null || \
              echo "â„¹ï¸ Import for $resource_name attempted"
            fi
          }
          
          # Parse and import each resource
          echo "$RESOURCES" | jq -r '.[] | "\(.id)|\(.type)|\(.name)"' | while IFS='|' read -r resource_id resource_type resource_name; do
            case "$resource_type" in
              "Microsoft.Network/virtualNetworks")
                import_with_generation "$resource_id" "$resource_type" "$resource_name" "module.virtualnetwork.azurerm_virtual_network.this"
                ;;
              "Microsoft.Web/sites")
                import_with_generation "$resource_id" "$resource_type" "$resource_name" "module.function_app.azurerm_linux_function_app.main"
                ;;
              "Microsoft.DocumentDB/databaseAccounts")
                import_with_generation "$resource_id" "$resource_type" "$resource_name" "module.cosmos_db.azurerm_cosmosdb_account.this"
                ;;
              "Microsoft.KeyVault/vaults")
                import_with_generation "$resource_id" "$resource_type" "$resource_name" "module.key_vault.azurerm_key_vault.this"
                ;;
              "Microsoft.Storage/storageAccounts")
                if [[ ! "$resource_name" =~ "tfstate" ]]; then
                  import_with_generation "$resource_id" "$resource_type" "$resource_name" "module.storage.azurerm_storage_account.main"
                fi
                ;;
              "Microsoft.Web/staticSites")
                import_with_generation "$resource_id" "$resource_type" "$resource_name" "module.static_web_app.azurerm_static_web_app.main"
                ;;
              "Microsoft.Insights/components")
                import_with_generation "$resource_id" "$resource_type" "$resource_name" "module.app_insights[0].azurerm_application_insights.main"
                ;;
            esac
          done
          
          # Display generated configurations
          if ls generated_*.tf 1> /dev/null 2>&1; then
            echo ""
            echo "âœ… Generated configuration files:"
            ls -la generated_*.tf | awk '{print "   " $9}'
            echo ""
            echo "ğŸ“ Review generated configs and merge into your Terraform modules if needed"
          fi
          
          echo "âœ… Resource import and config generation complete"

      - name: Terraform Plan
        if: steps.check-resources.outputs.exists == 'false'
        working-directory: .
        run: |
          terraform plan -var-file="dev.tfvars" -out=tfplan
          echo "âœ… Terraform plan created"

      - name: Terraform Apply
        if: steps.check-resources.outputs.exists == 'false'
        working-directory: .
        run: |
          terraform apply -auto-approve tfplan
          echo "âœ… Infrastructure deployed"
        
      - name: Initialize Terraform for existing resources
        if: steps.check-resources.outputs.exists == 'true'
        working-directory: .
        run: |
          terraform init
          terraform refresh -var-file="dev.tfvars" || true
          echo "âœ… Terraform initialized for existing resources"

      - name: Get Terraform Outputs
        id: terraform-output
        working-directory: .
        run: |
          # Refresh state if resources already exist
          terraform refresh -var-file="dev.tfvars" || true
          
          echo "function_app_name=$(terraform output -raw function_app_name)" >> $GITHUB_OUTPUT
          echo "function_app_url=$(terraform output -raw function_app_url)" >> $GITHUB_OUTPUT
          echo "static_web_app_name=$(terraform output -raw static_web_app_name)" >> $GITHUB_OUTPUT
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "âœ… Terraform outputs extracted"

  # ============================================
  # Job 1b: Fetch Existing Infrastructure (if skipping Terraform)
  # ============================================
  fetch-infrastructure:
    name: 'Fetch Existing Infrastructure'
    if: github.event.inputs.deploy_infrastructure == 'false'
    runs-on: ubuntu-latest
    outputs:
      function_app_name: ${{ steps.fetch-outputs.outputs.function_app_name }}
      function_app_url: ${{ steps.fetch-outputs.outputs.function_app_url }}
      static_web_app_name: ${{ steps.fetch-outputs.outputs.static_web_app_name }}
      resource_group: ${{ steps.fetch-outputs.outputs.resource_group }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Fetch Infrastructure Details
        id: fetch-outputs
        run: |
          # Read values from dev.tfvars
          RESOURCE_GROUP=$(grep 'resource_group_name' dev.tfvars | cut -d'=' -f2 | tr -d ' "')
          FUNCTION_APP=$(grep 'function_app_name' dev.tfvars | cut -d'=' -f2 | tr -d ' "')
          STATIC_WEB_APP=$(grep 'static_web_app_name' dev.tfvars | cut -d'=' -f2 | tr -d ' "')
          
          # Get Function App URL from Azure
          FUNCTION_APP_URL="https://$(az functionapp show --resource-group $RESOURCE_GROUP --name $FUNCTION_APP --query defaultHostName -o tsv)"
          
          echo "function_app_name=$FUNCTION_APP" >> $GITHUB_OUTPUT
          echo "function_app_url=$FUNCTION_APP_URL" >> $GITHUB_OUTPUT
          echo "static_web_app_name=$STATIC_WEB_APP" >> $GITHUB_OUTPUT
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "âœ… Existing infrastructure details fetched"

  # ============================================
  # Job 2: Deploy Function App (Backend)
  # ============================================
  deploy-backend:
    name: 'Deploy Function App (Python Backend)'
    if: github.event.inputs.deploy_backend == 'true'
    needs: [changes, infrastructure, fetch-infrastructure]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Python dependencies
        working-directory: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt --target=".python_packages/lib/site-packages"
          echo "âœ… Python dependencies installed"

      - name: Azure CLI Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy Function App Code
        uses: Azure/functions-action@v1
        with:
          app-name: ${{ (github.event.inputs.deploy_infrastructure == 'true' && needs.infrastructure.outputs.function_app_name) || needs.fetch-infrastructure.outputs.function_app_name }}
          package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          scm-do-build-during-deployment: true
          enable-oryx-build: true

      - name: Verify Function App Deployment
        run: |
          # Wait for function app to be ready
          sleep 10
          
          # Test health endpoint
          FUNCTION_APP_URL="${{ (github.event.inputs.deploy_infrastructure == 'true' && needs.infrastructure.outputs.function_app_url) || needs.fetch-infrastructure.outputs.function_app_url }}"
          HEALTH_CHECK=$(curl -s -o /dev/null -w "%{http_code}" "$FUNCTION_APP_URL/api/health")
          
          if [ "$HEALTH_CHECK" = "200" ]; then
            echo "âœ… Function App is healthy"
          else
            echo "âš ï¸ Function App health check returned: $HEALTH_CHECK"
          fi

  # ============================================
  # Job 3: Deploy Static Web App (Frontend)
  # ============================================
  deploy-frontend:
    name: 'Deploy Static Web App (React Frontend)'
    if: github.event.inputs.deploy_frontend == 'true'
    needs: [changes, infrastructure, fetch-infrastructure]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          

      - name: Install Node dependencies
        working-directory: app/frontend
        run: |
          npm ci
          echo "âœ… Node dependencies installed"

      - name: Build React Frontend
        working-directory: app/frontend
        env:
          REACT_APP_API_URL: ${{ (github.event.inputs.deploy_infrastructure == 'true' && needs.infrastructure.outputs.function_app_url) || needs.fetch-infrastructure.outputs.function_app_url }}/api
          CI: false
        run: |
          npm run build
          echo "âœ… Frontend built successfully"

      - name: Deploy to Static Web App
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "app/frontend/build"
          skip_app_build: true

  # ============================================
  # Job 4: Verify Deployment & Output Results
  # ============================================
  verify-deployment:
    name: 'Verify Deployment & Output Results'
    if: |
      always() &&
      (github.event.inputs.deploy_backend == 'true' || github.event.inputs.deploy_frontend == 'true')
    needs: [changes, infrastructure, fetch-infrastructure, deploy-backend, deploy-frontend]
    runs-on: ubuntu-latest
    
    steps:
      - name: Test API Endpoints
        if: github.event.inputs.deploy_backend == 'true'
        run: |
          echo "ğŸ§ª Testing API endpoints..."
          
          FUNCTION_APP_URL="${{ (github.event.inputs.deploy_infrastructure == 'true' && needs.infrastructure.outputs.function_app_url) || needs.fetch-infrastructure.outputs.function_app_url }}"
          
          # Health check
          HEALTH=$(curl -s -w "\n%{http_code}" "$FUNCTION_APP_URL/api/health")
          HTTP_CODE=$(echo "$HEALTH" | tail -n1)
          BODY=$(echo "$HEALTH" | head -n1)
          
          echo "Health Check Response: $BODY"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… Health endpoint working"
          else
            echo "âš ï¸ Health endpoint returned: $HTTP_CODE"
          fi

      - name: Output Deployment Summary
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘           ğŸ‰ DEPLOYMENT COMPLETED SUCCESSFULLY ğŸ‰           â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“‹ Deployment Summary:"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo ""
          if [ "${{ github.event.inputs.deploy_frontend }}" = "true" ]; then
            echo "ğŸŒ FRONTEND (React Application):"
            echo "   Static Web App Name: ${{ (github.event.inputs.deploy_infrastructure == 'true' && needs.infrastructure.outputs.static_web_app_name) || needs.fetch-infrastructure.outputs.static_web_app_name }}"
            echo ""
          fi
          if [ "${{ github.event.inputs.deploy_backend }}" = "true" ]; then
            echo "âš™ï¸  BACKEND (Python Function App):"
            echo "   Function App Name: ${{ (github.event.inputs.deploy_infrastructure == 'true' && needs.infrastructure.outputs.function_app_name) || needs.fetch-infrastructure.outputs.function_app_name }}"
            echo "   Function App URL:  ${{ (github.event.inputs.deploy_infrastructure == 'true' && needs.infrastructure.outputs.function_app_url) || needs.fetch-infrastructure.outputs.function_app_url }}"
            echo "   Health Endpoint:   ${{ (github.event.inputs.deploy_infrastructure == 'true' && needs.infrastructure.outputs.function_app_url) || needs.fetch-infrastructure.outputs.function_app_url }}/api/health"
            echo ""
          fi
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "Deploy Time: $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
